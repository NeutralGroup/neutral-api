// Code generated by protoc-gen-go. DO NOT EDIT.
// source: neutralservices.proto

package neutralservice

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("neutralservices.proto", fileDescriptor_1117a2e64aebac82) }

var fileDescriptor_1117a2e64aebac82 = []byte{
	// 451 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x94, 0xcd, 0x6e, 0x13, 0x41,
	0x0c, 0xc7, 0x37, 0x12, 0x02, 0xd5, 0x8d, 0x2a, 0x75, 0xa4, 0xa0, 0x6a, 0x41, 0x04, 0xf6, 0x80,
	0xe0, 0x12, 0xa1, 0xf0, 0x00, 0xa8, 0x2d, 0x50, 0x2a, 0x54, 0x08, 0x6d, 0xe1, 0xc0, 0xa1, 0xd2,
	0x64, 0xe2, 0x2e, 0xa6, 0x3b, 0xe3, 0xed, 0x8c, 0xb7, 0x10, 0x1e, 0x87, 0xf7, 0xe3, 0x1d, 0xd0,
	0xb6, 0xfb, 0x91, 0x66, 0x1b, 0xb8, 0xc0, 0xd1, 0xf6, 0xdf, 0x3f, 0x7b, 0xed, 0x59, 0xc3, 0xc0,
	0x61, 0x21, 0x5e, 0x67, 0x01, 0xfd, 0x05, 0x19, 0x0c, 0xa3, 0xdc, 0xb3, 0xb0, 0xda, 0xb8, 0xee,
	0x8e, 0x37, 0xb4, 0x31, 0x5c, 0x38, 0xa9, 0xe2, 0xf1, 0x26, 0xb9, 0x20, 0xbe, 0xb0, 0xd8, 0xba,
	0xfa, 0xe7, 0x05, 0x0b, 0x36, 0x96, 0x61, 0x6b, 0xd9, 0x5d, 0x59, 0xe3, 0x9f, 0xb7, 0x60, 0xfd,
	0x63, 0x40, 0xbf, 0xa7, 0x05, 0xbf, 0xe9, 0xb9, 0x7a, 0x0f, 0x77, 0x53, 0x94, 0x89, 0xa7, 0x0b,
	0x2d, 0x78, 0x84, 0x21, 0x10, 0xbb, 0x63, 0x3e, 0x43, 0xa7, 0x06, 0xa3, 0xeb, 0x95, 0x47, 0xaf,
	0x6c, 0x2e, 0xf3, 0xf8, 0xfe, 0xb2, 0x7b, 0x31, 0x29, 0x89, 0xd4, 0x3b, 0x18, 0x94, 0xc0, 0x62,
	0x9a, 0x91, 0xf9, 0x17, 0xbc, 0x3d, 0x58, 0xaf, 0xbe, 0x78, 0xdf, 0x9d, 0xf2, 0x2a, 0xca, 0x70,
	0xd9, 0x5d, 0x7e, 0xe3, 0x76, 0x9b, 0x97, 0x44, 0x8a, 0x60, 0x2b, 0x45, 0xd9, 0x6f, 0xa6, 0xf5,
	0x12, 0x4f, 0xc9, 0x91, 0x10, 0xbb, 0xa0, 0x1e, 0x2d, 0xa7, 0xb7, 0xb2, 0x43, 0x3c, 0x2f, 0x30,
	0x48, 0xfc, 0xa4, 0xd3, 0x27, 0xa5, 0x0e, 0x67, 0x8b, 0xc2, 0x90, 0xb3, 0x0b, 0x98, 0x44, 0xea,
	0x04, 0x06, 0xa1, 0x98, 0x06, 0xe3, 0x69, 0x8a, 0xc7, 0x5c, 0xb6, 0xf2, 0xe1, 0x72, 0x23, 0xea,
	0x61, 0x07, 0x52, 0xcb, 0xea, 0x32, 0xc3, 0x9b, 0xcb, 0x34, 0x8c, 0x24, 0x7a, 0xd6, 0x53, 0x27,
	0x70, 0x07, 0xbf, 0xa3, 0x29, 0x04, 0xd5, 0xe3, 0x4e, 0xe7, 0xd6, 0xe2, 0x8c, 0xb4, 0xe0, 0x2e,
	0x5b, 0x4b, 0x4d, 0xfb, 0x4f, 0x6f, 0xe6, 0xbe, 0x26, 0xa7, 0xb3, 0x5a, 0x59, 0xf7, 0x3f, 0x3e,
	0x83, 0xb5, 0x4f, 0x3a, 0xa3, 0x99, 0x16, 0xf6, 0xff, 0xbd, 0xd8, 0xaf, 0x1e, 0x6c, 0x56, 0x9b,
	0x3a, 0xd0, 0x4e, 0xa7, 0x58, 0x0e, 0x53, 0xbd, 0x05, 0x48, 0x51, 0x2a, 0xbf, 0x7a, 0xb0, 0x0c,
	0xac, 0x02, 0x75, 0xc1, 0x7b, 0x2b, 0xe2, 0xd5, 0xea, 0xdf, 0x00, 0x84, 0x16, 0xf6, 0x27, 0xf1,
	0xdf, 0x48, 0xdb, 0xd0, 0xcf, 0x28, 0xd4, 0xa8, 0xb0, 0xea, 0x39, 0x6e, 0xad, 0xa0, 0x84, 0x24,
	0x1a, 0x7f, 0x86, 0xb5, 0x5d, 0xed, 0xd8, 0x91, 0xd1, 0x99, 0x3a, 0x80, 0xbe, 0xa9, 0x0d, 0xfa,
	0x81, 0xaa, 0x9b, 0xe8, 0xe6, 0xf2, 0x85, 0x5c, 0x1a, 0x77, 0x9e, 0x68, 0x03, 0x69, 0x67, 0xb9,
	0xf3, 0x02, 0x86, 0x86, 0x6d, 0xad, 0xcc, 0x3d, 0x7f, 0x45, 0x23, 0xa3, 0xe6, 0xa2, 0xf8, 0xdc,
	0xec, 0xc4, 0x0b, 0x7f, 0xff, 0x61, 0x6e, 0x8e, 0xae, 0x62, 0x93, 0xf2, 0x38, 0x4c, 0x7a, 0xd3,
	0xdb, 0x97, 0x57, 0xe2, 0xf9, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa6, 0x4c, 0x7f, 0x0b, 0x8d,
	0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// UserGatewayClient is the client API for UserGateway service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UserGatewayClient interface {
	GetPrivateSessionToken(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SessionToken, error)
	GetPublicSessionToken(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SessionToken, error)
	AccountInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*UserAccountInfo, error)
	GetInstrumentDefinitions(ctx context.Context, in *InstrumentRequest, opts ...grpc.CallOption) (*SignedInstrumentResponse, error)
	SubscribeToUserQuotes(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (UserGateway_SubscribeToUserQuotesClient, error)
	Execute(ctx context.Context, in *ImmediateCommitRequest, opts ...grpc.CallOption) (*SignedFinalCommitResponse, error)
}

type userGatewayClient struct {
	cc *grpc.ClientConn
}

func NewUserGatewayClient(cc *grpc.ClientConn) UserGatewayClient {
	return &userGatewayClient{cc}
}

func (c *userGatewayClient) GetPrivateSessionToken(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SessionToken, error) {
	out := new(SessionToken)
	err := c.cc.Invoke(ctx, "/neutralservice.UserGateway/getPrivateSessionToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userGatewayClient) GetPublicSessionToken(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SessionToken, error) {
	out := new(SessionToken)
	err := c.cc.Invoke(ctx, "/neutralservice.UserGateway/getPublicSessionToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userGatewayClient) AccountInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*UserAccountInfo, error) {
	out := new(UserAccountInfo)
	err := c.cc.Invoke(ctx, "/neutralservice.UserGateway/accountInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userGatewayClient) GetInstrumentDefinitions(ctx context.Context, in *InstrumentRequest, opts ...grpc.CallOption) (*SignedInstrumentResponse, error) {
	out := new(SignedInstrumentResponse)
	err := c.cc.Invoke(ctx, "/neutralservice.UserGateway/getInstrumentDefinitions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userGatewayClient) SubscribeToUserQuotes(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (UserGateway_SubscribeToUserQuotesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UserGateway_serviceDesc.Streams[0], "/neutralservice.UserGateway/subscribeToUserQuotes", opts...)
	if err != nil {
		return nil, err
	}
	x := &userGatewaySubscribeToUserQuotesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UserGateway_SubscribeToUserQuotesClient interface {
	Recv() (*SignedUserQuote, error)
	grpc.ClientStream
}

type userGatewaySubscribeToUserQuotesClient struct {
	grpc.ClientStream
}

func (x *userGatewaySubscribeToUserQuotesClient) Recv() (*SignedUserQuote, error) {
	m := new(SignedUserQuote)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *userGatewayClient) Execute(ctx context.Context, in *ImmediateCommitRequest, opts ...grpc.CallOption) (*SignedFinalCommitResponse, error) {
	out := new(SignedFinalCommitResponse)
	err := c.cc.Invoke(ctx, "/neutralservice.UserGateway/execute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserGatewayServer is the server API for UserGateway service.
type UserGatewayServer interface {
	GetPrivateSessionToken(context.Context, *Empty) (*SessionToken, error)
	GetPublicSessionToken(context.Context, *Empty) (*SessionToken, error)
	AccountInfo(context.Context, *Empty) (*UserAccountInfo, error)
	GetInstrumentDefinitions(context.Context, *InstrumentRequest) (*SignedInstrumentResponse, error)
	SubscribeToUserQuotes(*SubscribeRequest, UserGateway_SubscribeToUserQuotesServer) error
	Execute(context.Context, *ImmediateCommitRequest) (*SignedFinalCommitResponse, error)
}

// UnimplementedUserGatewayServer can be embedded to have forward compatible implementations.
type UnimplementedUserGatewayServer struct {
}

func (*UnimplementedUserGatewayServer) GetPrivateSessionToken(ctx context.Context, req *Empty) (*SessionToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrivateSessionToken not implemented")
}
func (*UnimplementedUserGatewayServer) GetPublicSessionToken(ctx context.Context, req *Empty) (*SessionToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPublicSessionToken not implemented")
}
func (*UnimplementedUserGatewayServer) AccountInfo(ctx context.Context, req *Empty) (*UserAccountInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountInfo not implemented")
}
func (*UnimplementedUserGatewayServer) GetInstrumentDefinitions(ctx context.Context, req *InstrumentRequest) (*SignedInstrumentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInstrumentDefinitions not implemented")
}
func (*UnimplementedUserGatewayServer) SubscribeToUserQuotes(req *SubscribeRequest, srv UserGateway_SubscribeToUserQuotesServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToUserQuotes not implemented")
}
func (*UnimplementedUserGatewayServer) Execute(ctx context.Context, req *ImmediateCommitRequest) (*SignedFinalCommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}

func RegisterUserGatewayServer(s *grpc.Server, srv UserGatewayServer) {
	s.RegisterService(&_UserGateway_serviceDesc, srv)
}

func _UserGateway_GetPrivateSessionToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserGatewayServer).GetPrivateSessionToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutralservice.UserGateway/GetPrivateSessionToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserGatewayServer).GetPrivateSessionToken(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserGateway_GetPublicSessionToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserGatewayServer).GetPublicSessionToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutralservice.UserGateway/GetPublicSessionToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserGatewayServer).GetPublicSessionToken(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserGateway_AccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserGatewayServer).AccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutralservice.UserGateway/AccountInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserGatewayServer).AccountInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserGateway_GetInstrumentDefinitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstrumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserGatewayServer).GetInstrumentDefinitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutralservice.UserGateway/GetInstrumentDefinitions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserGatewayServer).GetInstrumentDefinitions(ctx, req.(*InstrumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserGateway_SubscribeToUserQuotes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UserGatewayServer).SubscribeToUserQuotes(m, &userGatewaySubscribeToUserQuotesServer{stream})
}

type UserGateway_SubscribeToUserQuotesServer interface {
	Send(*SignedUserQuote) error
	grpc.ServerStream
}

type userGatewaySubscribeToUserQuotesServer struct {
	grpc.ServerStream
}

func (x *userGatewaySubscribeToUserQuotesServer) Send(m *SignedUserQuote) error {
	return x.ServerStream.SendMsg(m)
}

func _UserGateway_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImmediateCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserGatewayServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutralservice.UserGateway/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserGatewayServer).Execute(ctx, req.(*ImmediateCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _UserGateway_serviceDesc = grpc.ServiceDesc{
	ServiceName: "neutralservice.UserGateway",
	HandlerType: (*UserGatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "getPrivateSessionToken",
			Handler:    _UserGateway_GetPrivateSessionToken_Handler,
		},
		{
			MethodName: "getPublicSessionToken",
			Handler:    _UserGateway_GetPublicSessionToken_Handler,
		},
		{
			MethodName: "accountInfo",
			Handler:    _UserGateway_AccountInfo_Handler,
		},
		{
			MethodName: "getInstrumentDefinitions",
			Handler:    _UserGateway_GetInstrumentDefinitions_Handler,
		},
		{
			MethodName: "execute",
			Handler:    _UserGateway_Execute_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "subscribeToUserQuotes",
			Handler:       _UserGateway_SubscribeToUserQuotes_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "neutralservices.proto",
}

// ValidatorClient is the client API for Validator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ValidatorClient interface {
	Execute(ctx context.Context, in *ImmediateCommitRequest, opts ...grpc.CallOption) (*SignedFinalCommitResponse, error)
}

type validatorClient struct {
	cc *grpc.ClientConn
}

func NewValidatorClient(cc *grpc.ClientConn) ValidatorClient {
	return &validatorClient{cc}
}

func (c *validatorClient) Execute(ctx context.Context, in *ImmediateCommitRequest, opts ...grpc.CallOption) (*SignedFinalCommitResponse, error) {
	out := new(SignedFinalCommitResponse)
	err := c.cc.Invoke(ctx, "/neutralservice.Validator/execute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ValidatorServer is the server API for Validator service.
type ValidatorServer interface {
	Execute(context.Context, *ImmediateCommitRequest) (*SignedFinalCommitResponse, error)
}

// UnimplementedValidatorServer can be embedded to have forward compatible implementations.
type UnimplementedValidatorServer struct {
}

func (*UnimplementedValidatorServer) Execute(ctx context.Context, req *ImmediateCommitRequest) (*SignedFinalCommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}

func RegisterValidatorServer(s *grpc.Server, srv ValidatorServer) {
	s.RegisterService(&_Validator_serviceDesc, srv)
}

func _Validator_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImmediateCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidatorServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutralservice.Validator/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidatorServer).Execute(ctx, req.(*ImmediateCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Validator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "neutralservice.Validator",
	HandlerType: (*ValidatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "execute",
			Handler:    _Validator_Execute_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "neutralservices.proto",
}

// AccountManagementClient is the client API for AccountManagement service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AccountManagementClient interface {
	GetAccount(ctx context.Context, in *AccountRequest, opts ...grpc.CallOption) (*AccountInfo, error)
	SetAccount(ctx context.Context, in *AccountInfo, opts ...grpc.CallOption) (*AccountInfo, error)
	ListAccounts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Accounts, error)
}

type accountManagementClient struct {
	cc *grpc.ClientConn
}

func NewAccountManagementClient(cc *grpc.ClientConn) AccountManagementClient {
	return &accountManagementClient{cc}
}

func (c *accountManagementClient) GetAccount(ctx context.Context, in *AccountRequest, opts ...grpc.CallOption) (*AccountInfo, error) {
	out := new(AccountInfo)
	err := c.cc.Invoke(ctx, "/neutralservice.AccountManagement/getAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountManagementClient) SetAccount(ctx context.Context, in *AccountInfo, opts ...grpc.CallOption) (*AccountInfo, error) {
	out := new(AccountInfo)
	err := c.cc.Invoke(ctx, "/neutralservice.AccountManagement/setAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountManagementClient) ListAccounts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Accounts, error) {
	out := new(Accounts)
	err := c.cc.Invoke(ctx, "/neutralservice.AccountManagement/listAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountManagementServer is the server API for AccountManagement service.
type AccountManagementServer interface {
	GetAccount(context.Context, *AccountRequest) (*AccountInfo, error)
	SetAccount(context.Context, *AccountInfo) (*AccountInfo, error)
	ListAccounts(context.Context, *Empty) (*Accounts, error)
}

// UnimplementedAccountManagementServer can be embedded to have forward compatible implementations.
type UnimplementedAccountManagementServer struct {
}

func (*UnimplementedAccountManagementServer) GetAccount(ctx context.Context, req *AccountRequest) (*AccountInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccount not implemented")
}
func (*UnimplementedAccountManagementServer) SetAccount(ctx context.Context, req *AccountInfo) (*AccountInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAccount not implemented")
}
func (*UnimplementedAccountManagementServer) ListAccounts(ctx context.Context, req *Empty) (*Accounts, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAccounts not implemented")
}

func RegisterAccountManagementServer(s *grpc.Server, srv AccountManagementServer) {
	s.RegisterService(&_AccountManagement_serviceDesc, srv)
}

func _AccountManagement_GetAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountManagementServer).GetAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutralservice.AccountManagement/GetAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountManagementServer).GetAccount(ctx, req.(*AccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountManagement_SetAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountManagementServer).SetAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutralservice.AccountManagement/SetAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountManagementServer).SetAccount(ctx, req.(*AccountInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountManagement_ListAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountManagementServer).ListAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutralservice.AccountManagement/ListAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountManagementServer).ListAccounts(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _AccountManagement_serviceDesc = grpc.ServiceDesc{
	ServiceName: "neutralservice.AccountManagement",
	HandlerType: (*AccountManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "getAccount",
			Handler:    _AccountManagement_GetAccount_Handler,
		},
		{
			MethodName: "setAccount",
			Handler:    _AccountManagement_SetAccount_Handler,
		},
		{
			MethodName: "listAccounts",
			Handler:    _AccountManagement_ListAccounts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "neutralservices.proto",
}

// CanonicalClient is the client API for Canonical service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CanonicalClient interface {
	Canonicalize(ctx context.Context, in *Anything, opts ...grpc.CallOption) (*CanonicalResponse, error)
}

type canonicalClient struct {
	cc *grpc.ClientConn
}

func NewCanonicalClient(cc *grpc.ClientConn) CanonicalClient {
	return &canonicalClient{cc}
}

func (c *canonicalClient) Canonicalize(ctx context.Context, in *Anything, opts ...grpc.CallOption) (*CanonicalResponse, error) {
	out := new(CanonicalResponse)
	err := c.cc.Invoke(ctx, "/neutralservice.Canonical/canonicalize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CanonicalServer is the server API for Canonical service.
type CanonicalServer interface {
	Canonicalize(context.Context, *Anything) (*CanonicalResponse, error)
}

// UnimplementedCanonicalServer can be embedded to have forward compatible implementations.
type UnimplementedCanonicalServer struct {
}

func (*UnimplementedCanonicalServer) Canonicalize(ctx context.Context, req *Anything) (*CanonicalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Canonicalize not implemented")
}

func RegisterCanonicalServer(s *grpc.Server, srv CanonicalServer) {
	s.RegisterService(&_Canonical_serviceDesc, srv)
}

func _Canonical_Canonicalize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Anything)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanonicalServer).Canonicalize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutralservice.Canonical/Canonicalize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanonicalServer).Canonicalize(ctx, req.(*Anything))
	}
	return interceptor(ctx, in, info, handler)
}

var _Canonical_serviceDesc = grpc.ServiceDesc{
	ServiceName: "neutralservice.Canonical",
	HandlerType: (*CanonicalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "canonicalize",
			Handler:    _Canonical_Canonicalize_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "neutralservices.proto",
}
